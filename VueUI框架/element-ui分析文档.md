# scripts 脚本分析

## build:file

### iconInit

- iconInit.js 作用，根据 icon.scss 中的内容，将所有.el-icon-info:before 中的 info 匹配出来放到 icon.json 文件中

### build-entry

- 根据模板代码，生成入口文件，放到/src/index.js 中，在 vue 中注册所有的组件的地方，
- 在最终文件里能看到`/* Automatically generated by './build/bin/build-entry.js' */`

### i18n

- i18n

### version

- version

## webpack.conf.js

- 打总包，入口就是通过`build-entry`生成的`/src/index.js`，libraryTarget 为 umd
- `publicPath: '/dist/'` 表示代码中的 publicPath 路径
- `path: 'lib'` 表示打包出来的文件放在 lib 下
- 生成的目标文件为 umd 格式，文件名为 index.js，进行了压缩
  - umd 格式可以将你的库暴露在所有的模块定义中，可以和 CommonJS, AMD 一起工作，或者作为一个全局变量，这种配置下需要指定 library 属性，给模块命个名称
- 在 cdn 网站上获取到的就是默认的 lib/index.js，umd 格式可以支持在 script 中引入

```js
const path = require("path");
const TerserPlugin = require("terser-webpack-plugin");

const config = require("./config");

module.exports = {
  mode: "production",
  entry: {
    app: ["./src/index.js"],
  },
  output: {
    path: path.resolve(process.cwd(), "./lib"),
    publicPath: "/dist/",
    filename: "index.js",
    chunkFilename: "[id].js",
    // 通用的，支持多种模块的格式
    libraryTarget: "umd",
    // Specify which export should be exposed as a library.
    // 配置哪个模块会通过libraryTarget暴露，默认是undefined
    // 配置为default表示入口文件的默认导出会被指定为the library target
    libraryExport: "default", // 建议通过output.library.export配置
    // 指定模块名称
    library: "ELEMENT",
    // 当libraryTarget: "umd"时，true 表示会命名UMD构建的AMD模块，否则会使用一个匿名的define
    umdNamedDefine: true, // 建议通过output.library.umdNamedDefine配置
    // 表示哪个全局对象会被使用以用来挂载库
    // 为了让umd构建在浏览器和node.js都能使用，设置此选项为this，默认值是给Web-like targets使用的self
    // self可以在浏览器环境的window下，和web worker中使用
    // this在浏览器环境和nodejs环境下可以使用
    // 所以下面这个判断就兼顾了所有场景
    globalObject: "typeof self !== 'undefined' ? self : this",
  },
  resolve: {
    extensions: [".js", ".vue", ".json"],
    alias: config.alias,
  },
  externals: {
    vue: config.vue,
  },
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          output: {
            comments: false,
          },
        },
      }),
    ],
  },
  performance: {
    hints: false,
  },
  stats: {
    children: false,
  },
};
```

## webpack.common.js

- 大部分和 conf 相同
- 生成的目标文件为 commonjs2 格式，文件名为 element-ui.common.js，未压缩，也是 package.json 中库默认入口（main 配置项）
- 通过`import ElementUI from 'element-ui'`使用时，加载的是 element-ui.common.js
- [stats 配置](https://webpack.docschina.org/configuration/stats/#statschildren) 控制构建输出的统计信息，以及以怎样的格式展示

```js
const path = require("path");
const config = require("./config");

module.exports = {
  mode: "production",
  entry: {
    app: ["./src/index.js"],
  },
  output: {
    path: path.resolve(process.cwd(), "./lib"),
    publicPath: "/dist/",
    filename: "element-ui.common.js",
    chunkFilename: "[id].js",
    libraryExport: "default",
    library: "ELEMENT",
    libraryTarget: "commonjs2",
  },
  resolve: {
    extensions: [".js", ".vue", ".json"],
    alias: config.alias,
    modules: ["node_modules"],
  },
  externals: config.externals,
  performance: {
    hints: false,
  },
  stats: {
    children: false,
  },
  optimization: {
    minimize: false,
  },
};
```

## webpack.component.js

- 大部分和 common 相同，生成的目标文件也是 commonjs2 格式
- 用于给每个组件打包，多入口打包，入口读取的是 components.json 配置，出口以每个组件名称命名
- 没有配置 libraryExport（配置打包后的模块或库导出哪些成员）和 library
- lib 文件夹下以每个组件命名的.js 文件就是这里生成的，是每个单独组件的入口
- 项目中按需导入时`import { Button, Select } from 'element-ui';`，加载的是对应组件的入口

```js
const path = require("path");
const Components = require("../components.json");
const config = require("./config");

const webpackConfig = {
  mode: "production",
  entry: Components,
  output: {
    path: path.resolve(process.cwd(), "./lib"),
    publicPath: "/dist/",
    filename: "[name].js",
    chunkFilename: "[id].js",
    libraryTarget: "commonjs2",
  },
  resolve: {
    extensions: [".js", ".vue", ".json"],
    alias: config.alias,
    modules: ["node_modules"],
  },
  externals: config.externals,
  performance: {
    hints: false,
  },
  stats: "none",
  optimization: {
    minimize: false,
  },
};

module.exports = webpackConfig;
```

## build:utils

- 使用 babel 对 src 文件夹下的文件进行处理，输出到 lib 文件夹下，不处理 src/index.js

## build:umd

- 使用 Babel 处理 locale 国际化相关文件。存储到 lib/umd/locale 下

## build:theme

### gen-cssfile

- 默认`theme = theme-chalk`， isSCSS 为 true
- 在前面加上引入 base.scss，再循环 componets（除了['icon', 'option', 'option-group']数组中的），得到最终的入口 index.scss，里面引入了所有组件样式文件

### gulpfile.js

- gulp 打包处理 scss
- 将所有 scss 转换成 css 放到 lib 下，有每个组件单独的 css，index.css 是全部的样式
- 将 fonts 中的所有内容复制到 lib/fonts 下

### cp-cli

- 拷贝 packages/theme-chalk/lib 到 lib/theme-chalk
- 至此，Lib 下所有文件来源都清楚了

## 按需加载

- [babel-plugin-component](https://www.npmjs.com/package/babel-plugin-component)

```js
import { Button, Select } from "element-ui";
import App from "./App.vue";

Vue.component(Button.name, Button);
Vue.component(Select.name, Select);
```

- 不需要再导入 css，babel 插件默认会将对应的 css 导入，并且还会导入 base.css

```json
styleLibrary: {
  "name": "xxx", // same with styleLibraryName
  "base": true,  // if theme package has a base.css
  "path": "[module]/index.css",  // the style path. e.g. module Alert =>  alert/index.css
  "mixin": true  // if theme-package not found css file, then use [libraryName]'s css file
}
```

# 资料

- [libraryTarget 的几种选择](https://zhuanlan.zhihu.com/p/108216236)
