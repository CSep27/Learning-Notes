进度：资料看了一遍，待深入学习整理

# 资料

[MDN-内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management#data_structures_aiding_memory_management)

[JS 中的栈内存堆内存](https://juejin.im/post/5d116a9df265da1bb47d717b)

[你不知道的 JS（2）深入了解闭包](https://www.cnblogs.com/wuguanglin/p/closure.html)

[堆栈与堆（Stack vs Heap）：有什么区别？](https://cloud.tencent.com/developer/article/2367306)

[JS 中的内存管理](https://juejin.cn/post/6844903869525262349)

# 内存管理

## 内存生命周期

不管什么程序语言，内存生命周期基本是一致的：

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

## JavaScript 的内存分配

### 值的初始化

JavaScript 在定义变量时就完成了内存分配。

```js
var n = 123; // 给数值变量分配内存
var s = "azerty"; // 给字符串分配内存

var o = {
  a: 1,
  b: null,
}; // 给对象及其包含的值分配内存
```

### 通过函数调用分配内存

有些函数调用结果是分配对象内存：

```js
var d = new Date(); // 分配一个 Date 对象

var e = document.createElement("div"); // 分配一个 DOM 元素
```

有些方法分配新变量或者新对象：

```js
var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。

var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// 新数组有四个元素，是 a 连接 a2 的结果
```

## 垃圾回收算法

1. 引用计数
2. 标记清除 （2012 年起所有浏览器使用的新算法）
   - 这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。
   - 垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……
   - 从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
   - 所有不能获得的对象即需要清除的对象。

# 栈和堆

## 栈（堆栈 stack）

栈存储器的主要特点：

- 固定大小：当涉及到堆栈内存时，其大小保持固定，并在程序执行开始时确定。
- 速度优势：堆栈内存帧是连续的。因此，在堆栈内存中分配和释放内存的速度非常快。这是通过操作系统管理的堆栈指针对引用进行简单调整来完成的。
- 控制信息和变量的存储：堆栈内存负责容纳控制信息、局部变量和函数参数，包括返回地址。
- 有限的可访问性：存储在堆栈内存中的数据只能在活动函数调用期间访问。
- 自动管理：堆栈内存的高效管理由系统本身完成，不需要我们额外的工作。

## 堆

堆内存，也称为动态内存，程序员必须手动管理它。堆内存允许我们在程序执行期间随时分配和释放内存。它非常适合存储大型数据结构或大小事先未知的对象。

堆内存的主要特点：

- 大小的灵活性：堆内存大小可以在程序执行过程中发生变化。
- 速度权衡：在堆中分配和释放内存速度较慢，因为它涉及寻找合适的内存帧和处理碎片。
- 动态对象的存储：堆内存存储具有动态生命周期的对象和数据结构，如 newJava 或 C++ 中使用关键字创建的对象和数据结构。
- 持久数据：存储在堆内存中的数据将一直保留在那里，直到我们手动释放它或程序结束。
- 手动管理：在某些编程语言（例如 C 和 C++）中，必须手动管理堆内存。如果处理不当，可能会导致内存泄漏或资源使用效率低下。（JS 通过垃圾回收管理内存释放，无需手动干预。）

# JS 变量存储

JS 的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。

其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。

基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。

引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。（引用计数、标记清除）

## 闭包中的变量保存

闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

闭包中函数里的变量是分配在堆中还是栈中？

现代 JS 引擎通过逃逸分析是可以知道哪些需要分配在栈上，哪些需要分配在堆上的。闭包中使用到的变量会分配在堆中，没有使用到的简单类型对象还是会分配在栈中，以方便回收。

注：逃逸分析，见《JS 引擎》中的资料

```js
// 闭包示例代码
function A() {
  let a = 1;
  function B() {
    console.log(a);
  }
  return B;
}
let res = A();
```

函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

函数 A 弹出调用栈后，函数 B 用到了函数 A 中的变量 a，变量 a 这时候是存储在堆上的，所以函数 B 依旧能引用到函数 A 中的变量。

不合理的使用闭包会造成内存泄漏

## 如何避免内存泄漏

一个原则：不用的东西，及时归还。

- 减少不必要的全局变量，使用严格模式避免意外创建全局变量。
- 在使用完数据后，及时解除引用（闭包中的变量，dom 引用，定时器清除）。
- 组织好逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。
