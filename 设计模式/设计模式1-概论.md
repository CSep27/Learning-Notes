### 代码与设计模式

- 项目 = 模块 + 沟通
- 设计模式的作用
  - 组织模块间的组成结构
    - 设计模块间如何沟通
    - 提高代码质量

### 设计原则

1. 开闭原则
   - 对扩展开放，对修改关闭
   - 例：Vue、Webpack 插件
2. 单一职责原则
   - 一个模块只做一件事，模块的功能越单一越好（主要关注模块本身）
3. 依赖倒置原则
   - 上层模块不要依赖于具体的下层模块，而应该依赖于抽象
   - 例如：有多种食物可选择，但是通过餐厅作为吃饭的依赖
   - 通过在中间添加一层抽象层（餐厅），使得具体使用的上层接口（点餐），不要被下层接口（食物）的变动影响
   ```
     function Food1() { }
     function Food2() { }
     function Food3() { }
     // 错误做法
     function Order() { }
     Order.prototype.orderFood1 = function () { }
     Order.prototype.orderFood2 = function () { }
     Order.prototype.orderFood3 = function () { }
     // 正确做法
     function Restaurant(food) {
       var menu = {
         food1: new Food1(),
         food2: new Food2(),
         food3: new Food3(),
       }
       return menu[food]
     }
     function Order(food) {
       return Restaurant(food)
     }
   ```
4. 接口隔离原则
   - 接口应该细化，功能应该单一（关注接口）
5. 迪米特法则（最少知识原则）
   - 两个对象之间产生沟通，最好让他们互相知道的越少越好
   - 应用：中介者模式
6. 里氏替换原则
   - 子类继承父类时，保证完全继承父类的属性和方法，使用父类的地方，子类可以进行替换

### 设计模式分类

1. 创建型 - 帮助我们优雅地创建对象
   - 工厂模式 - 大量创建对象
   - 单例模式 - 全局只能有我一个
   - 建造者模式 - 精细化组合对象，用于创建复杂对象
   - 原型模式 - JavaScript 的灵魂
2. 结构型 - 帮助我们优雅地设计代码结构
   - 外观模式 - 给你一个套餐
   - 享元模式 - 共享来减少数量
   - 适配器模式 - 用适配代替更改
   - 桥接模式 - 独立出来，然后再对接过去，减小代码耦合度
   - 装饰者模式 - 更优雅地扩展需求
3. 行为型 - 模块之间行为模式的总结，帮助我们组织模块行为
   - 观察者模式 - 两个模块的沟通通过第三方转发，
   - 职责链模式 - 像生产线一样组织模块
   - 状态模式 - 用状态代替判断
   - 命令模式 - 用命令去解除执行者和命令者之间的耦合
   - 策略模式 - 算法工厂
   - 迭代器模式 - 告别 for 循环 （例 ES6 的 forEach 循环）
4. 技巧型 - 优化代码的技巧
   - 链模式 - 链式调用
   - 惰性模式 - 机器学习（第一次执行后，记录下执行状态）
   - 委托模式 - 将消息委托给他人代收
   - 等待者模式 - 多个异步操作都成功再进行下一步操作
   - 数据访问模式 - 一个方便的数据管理器
