# Cross Site Request Forgery (CSRF)

CSRF 介绍：[Cross Site Request Forgery](https://owasp.org/www-community/attacks/csrf)

跨站请求伪造是强迫用户在已经授权的网站上执行非本意的操作的一种攻击，属于被动攻击。

## 描述

攻击者使用 CSRF 获取到受害人的隐私数据，通过一种被称作登录 CSRF 的特殊形式的攻击。攻击者强迫一个未授权的用户登录攻击者控制的账户，如果受害人没意识到，

- login CSRF
- stored CSRF flaws
  通过在一块区域存放一个 IMG 或者 IRAME 标签，能够接受 HTML 或者更复杂的跨站脚本攻击。

## 无效的措施

1. 使用加密的 cookie (Using a secret cookie)
2. 只接受 POST 请求（Only accepting POST requests）
3. 多步骤交互（Multi-Step Transactions）
4. URL 重写（URL Rewriting）
5. HTTPS
   - 本身对于防御 CSRF 无效
   - 但是，应该被认为是任何防御性措施被信任的先决条件
6. 验证 referrer 头部 （Validating the Referrer Header）
   - referrer 很容易被攻击者伪造
   - 有些用户和浏览器由于隐私设置或政策，可能不会发送 referrer
   - 从书签打开网页，referrer 为 null，可能会导致被误以为是攻击

## 例子

### 攻击如何生效

Alice wishes to transfer $100 to Bob using the bank.com web application that is vulnerable to CSRF. Maria, an attacker, wants to trick Alice into sending the money to Maria instead. The attack will comprise the following steps:

1. 构造一个攻击 URL 或脚本
2. 欺骗诱导 Alice 执行操作

#### GET 场景

正确的转账链接：
`GET http://bank.com/transfer.do?acct=BOB&amount=100 HTTP/1.1`

Maria 改造的链接:

`http://bank.com/transfer.do?acct=MARIA&amount=100000`

当 Alice 登录银行应用，欺骗她点击改造后的链接：

- 发送一个带有 HTML 内容的邮件
- 在网页上植入 URL 或者脚本，受害者本身线上转账时就有可能访问的。

链接看起来和普通链接一样：

`<a href="http://bank.com/transfer.do?acct=MARIA&amount=100000">View my Pictures!</a>`

`0*0` 大小的伪造图片
`<img src="http://bank.com/transfer.do?acct=MARIA&amount=100000" width="0" height="0" border="0">`

#### POST 场景

正确链接

```
POST http://bank.com/transfer.do HTTP/1.1

acct=BOB&amount=100
```

用 FORM 标签：

```
<form action="http://bank.com/transfer.do" method="POST">

<input type="hidden" name="acct" value="MARIA"/>
<input type="hidden" name="amount" value="100000"/>
<input type="submit" value="View my pictures"/>

</form>
```

用 JS 自动执行点击操作：

```
<body onload="document.forms[0].submit()">

<form...
```

## 相关的控制措施

- Add a per-request nonce to the URL and all forms in addition to the standard session. This is also referred to as “form keys”.
- Add a hash (session id, function name, server-side secret) to all forms.
- Checking the referrer header in the client’s HTTP request can prevent CSRF attacks. Ensuring that the HTTP request has come from the original site means that attacks from other sites will not function.（前面不是说没用？）
- 用户自己在访问其他网站前退出，或者清除 cookie

# Cross-Site Request Forgery Prevention Cheat Sheet

[如何防范 CSRF](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)

## 介绍

简单来说，以下用于防范 CSRF 的措施应该被遵守：

重要：XSS 会让所有的 CSRF 防御措施失效！

- 查看 the OWASP XSS Prevention Cheat Sheet，详细的指引关于如何防范 XSS 缺陷
- 第一点，检查你的框架有没有内置的 CSRF 防范措施，有的话使用它。
- 如果框架没有内置，添加 CSRF tokens 到所有状态改变的请求上（会导致网站操作的请求）并且在后端验证 tokens。
- 有状态的软件应该使用同步 token 模式（synchronizer token pattern）。
- 无状态的软件应该使用双重提交 cookies（double submit cookies）。
- 如果是一个 API 驱动的网站不应该使用`<form>`标签，考虑使用自定义请求头。
- 实现至少一种来自 Defense in Depth Mitigations 章节的防御措施。
- SameSite Cookie 属性可以用于 session cookies，但是小心**不要**特地为一个域名设置 cookie。这个举措会导致一个安全漏洞因为那个域名的所有子域名会分享这个 cookie，并且如果一个子域名有一个不在你控制范围的 CNAME 解析的话，尤其会成为一个问题。
- 对于高度敏感的操作，考虑实现基于保护措施的用户交互。
- 考虑使用标准头部验证域名。
- 对于改变状态的操作，不要使用 GET 请求。
- 如果你有任何理由这么做，保护这些资源免受 CSRF 攻击。

## 基于 Token 的措施 （Token-Based Mitigation）

The synchronizer token pattern is one of the most popular and recommended methods to mitigate CSRF.

### 使用内置的或者已存在防范 CSRF 的实现

许多框架内置了 synchronizer token defenses，可以直接使用。

### 同步 token 模式

CSRF tokens 应该在服务端生成，每个用户会话或者每个请求生成一次。对于每个请求对应一个 tokens 这种方式，攻击者利用偷来的 tokens，能使用的时间范围是最小的，比每个会话 token 更安全。但是每个请求对应一个 tokens 会导致更多可用性问题。

CSRF tokens 应该满足：

- 每个用户会话都有不同的 token
- 加密的
- 不可预测的（large random value generated by a secure method）

#### 使用同步规则传输 CSRF tokens

对于同步模式，CSRF token 不应该在 cookie 中传输

CSRF token 不能在服务日志或者 URL 中泄漏，GET 请求可能会泄漏 token。

自定义请求头自动遵循同源策略，因此 token 放在自定义 HTTP 请求头中更安全。

### 替代方案：使用二次提交 cookie 模式

如果在服务端保持 token 状态有问题，可以使用替代方案：二次提交 cookie（Using A Double-Submit Cookie Pattern）

#### 签名的二次提交 cookie（推荐）

Signed Double-Submit Cookie，使用一个只有服务端知道的密钥

推荐使用 HAMC 算法。把 token 和用户当前的 session 绑定。

生成 HMAC CSRF tokens（with a session-dependent user value），系统必须要：

- A session-dependent value that changes with each login session.For example, you could choose one of the following session-dependent values:
  - The server-side session ID (e.g. PHP or ASP.NET).
  - A random value (e.g. UUID) within a JWT that changes every time a JWT is created.
- A secret cryptographic key
  - This value is used to generate the HMAC hash. Ideally, store this key as an environment variable.
- A random value for anti-collision purposes.

#### 时间戳应该放在 token 中用于验证过期吗？

CSRF token 不是认证 token（access token）。它们是通过 session，使用 session 信息，来验证请求的真实性。新的 session 应该生成一个新的 token。

实现 HMAC CSRF tokens 的伪代码：

```
// Gather the values
secret = readEnvironmentVariable("CSRF_SECRET") // HMAC secret key
sessionID = session.sessionID // Current authenticated user session
randomValue = cryptographic.randomValue() // Cryptographic random value

// Create the CSRF Token
message = sessionID + "!" + randomValue // HMAC message payload
hmac = hmac("SHA256", secret, message) // Generate the HMAC hash
csrfToken = hmac + "." + message // Combine HMAC hash with message to generate the token. The plain message is required to later authenticate it against its HMAC hash

// Store the CSRF Token in a cookie
response.setCookie("csrf_token=" + csrfToken + "; Secure") // Set Cookie without HttpOnly flag
```

## 不允许简单请求

当用`<form>`标签提交数据时，会发送简单请求，不需要进行预检操作。因为浏览器允许简单请求发送到任何域，所以会有 CSRF 的风险。

### 不允许简单 content types

simple content types

- application/x-www-form-urlencoded
- multipart/form-data
- text/plain

Therefore a simple mitigation is for the server or API to disallow these simple content types.

### 将自定义请求头用于 AJAX/API

A user-friendly defense that is particularly well suited for AJAX or API endpoints is the use of a custom request header. No token is needed for this approach.

In this pattern, the client appends a custom header to requests that require CSRF protection. The header can be any arbitrary key-value pair, as long as it does not conflict with existing headers.

`X-YOURSITE-CSRF-PROTECTION=1`

When handling the request, the API checks for the existence of this header. If the header does not exist, the backend rejects the request as potential forgery. This approach has several advantages:

- UI changes are not required
- no server state is introduced to track tokens

总结：在使用 AJAX 或 API 的情况下，可以直接通过添加自定义请求头的方式防范 CSRF 攻击。有自定义请求头的请求会先发送预检请求，所以当服务端验证有自定义请求头，说明是来自浏览器的请求，并且已经发送过预检请求。

#### 自定义头部和 CORS

确保设置了“Access-Control-Allow-Origin”，从允许的域来的跨域请求能够设置自定义头部。

## 处理客户端 CSRF 攻击（重要）

客户端 CSRF 来源于 JS 程序使用了攻击者控制的输入，例如，URL，用于传递异步 HTTP 请求。

### 客户端 CSRF 举例

```html
<script type="text/javascript">
  var csrf_token = document
    .querySelector("meta[name='csrf-token']")
    .getAttribute("content");
  function ajaxLoad() {
    // process the URL hash fragment
    let hash_fragment = window.location.hash.slice(1);

    // hash fragment should be of the format: /^(get|post);(.*)$/
    // e.g., https://site.com/index/#post;/profile
    if (hash_fragment.length > 0 && hash_fragment.indexOf(";") > 0) {
      let params = hash_fragment.match(/^(get|post);(.*)$/);
      if (params && params.length) {
        let request_method = params[1];
        let request_endpoint = params[3];

        fetch(request_endpoint, {
          method: request_method,
          headers: {
            "XSRF-TOKEN": csrf_token,
            // [...]
          },
          // [...]
        }).then((response) => {
          /* [...] */
        });
      }
    }
  }
  // trigger the async request on page load
  window.onload = ajaxLoad();
</script>
```

### 客户端 CSRF 防范技术

- 独立的请求：Client-side CSRF can be prevented when asynchronous requests cannot be generated via attacker controllable inputs
- 输入验证：. These checks should strictly assess the format and choice of the values of the request parameters and decide whether they can only be used in non-state-changing operations (e.g., only allow GET requests and endpoints starting with a predefined prefix).
- 预定义的请求数据： Another mitigation technique is to store a list of predefined, safe request data in the JavaScript code (e.g., combinations of endpoints, request methods and other parameters that are safe to be replayed).

## 更深层的防御技术

### SameSite (Cookie Attribute)

This attribute helps the browser decide whether to send cookies along with cross-site requests. Possible values for this attribute are Lax, Strict, or None.

The Strict value will prevent the cookie from being sent by the browser to the target site in all cross-site browsing context, even when following a regular link.

```
Set-Cookie: JSESSIONID=xxxxx; SameSite=Strict
Set-Cookie: JSESSIONID=xxxxx; SameSite=Lax
```

这个属性不能替代 CSRF token，同时存在能更好的保护用户。

### 使用标准头部验证源（Origin）

1. 请求来自哪（source origin），通过 Origin 或 Referer 头部。
2. 请求去往哪(target origin).

在服务端，验证是否全部匹配。匹配才接受请求，否则丢弃。

这些头部是可靠的（属于 Forbidden header），因为不能被程序修改，只有浏览器可以设置。

#### 验证 source origin

##### 检查 Origin 头部

If the Origin header is present, verify that its value matches the target origin. Unlike the referer, the Origin header will be present in HTTP requests that originate from an HTTPS URL.

##### 如果 ORIGIN 不存在检查 REFERER

If the Origin header is not present, verify that the hostname in the Referer header matches the target origin.

---

这两种情况下，确保目标源（target origin）没问题。

#### 识别 target origin

不容易确定 target origin，通常服务器前面有很多代理。这种情况下可以考虑：

- 配置应用让它很容易知道它的目标源：Since it is your application, you can find its target origin and set that value in some server configuration entry. This would be the most secure approach as its defined server side, so it is a trusted value. if you can do it via some central configuration and provide your instances the ability to grab the value from it, that's great! (Note: Make sure the centralized configuration store is maintained securely because major part of your CSRF defense depends on it.)
- 使用 Host 头部值：The Host header is meant to contain the target origin of the request. But, if your app server is sitting behind a proxy, the Host header value is most likely changed by the proxy to the target origin of the URL behind the proxy, which is different than the original URL.
- 使用 X-Forwarded-Host 头部值：So the value in X-Forwarded-Host is likely to be the target origin value that you need to compare to the source origin in the Origin or Referer header.

**X-Forwarded-Host 不管用的场景：**

- 302 redirect cross-origin
- There are some privacy contexts where Origin is set to "null"
- Origin header is included for all cross origin requests but for same origin requests, in most browsers it is only included in POST/DELETE/PUT Note: Although it is not ideal, many developers use GET requests to do state changing operations.
- Referer 头部被忽略，比如负载均衡，代理等场景会去掉 Referer

#### 使用带有 Host 前缀的 Cookies 识别 Origins

如果 cookies 有`__Host-`前缀，例如：`Set-Cookie: __Host-token=RANDOM; path=/; Secure`，那么每个 cookie：

- 不能被其他子域覆盖
- 不能有`Domain`属性
- Must have the path of /.
- Must be marked as Secure

浏览器也支持`__Secure-`前缀，对于域名重写的限制要稍微宽松一些：

- 可以有`Domain`属性
- 可以被子域覆盖
- Path 可以有除了`/`之外的值

如果授权的用户想要访问不同（子）域，`__Secure-`可以作为"domain locked"`__Host-`前缀的替代。在其他场景下，除了`SameSite`属性，也推荐`__Host-`前缀。

### 基于用户交互的 CSRF 防御

- 重校验机制 (Re-Authentication mechanisms)
- 一次性 Tokens (One-time Tokens)

验证码（CAPTCHA）是专门设计用来用来应对机器的。可以让 CSRF 实现起来更加困难，但是不是专门用来防御 CSRF 的。

由于会对用户体验有影响，在一些重要场合（比如修改密码）可以用。

## 在登录表单中可能存在的 CSRF 漏洞

CSRF vulnerabilities can still occur on login forms where the user is not authenticated, but the impact and risk is different.

登录 CSRF 可以通过创建 pre-sessions（在用户授权之前的 sessions）和在登录表单中包含 tokens 来防御。记住一旦用户授权了，原来的 session 需要被销毁，创建一个新的，避免 session fixation attacks。

## JavaScript: 在 AJAX 请求头中自动包含 CSRF tokens

POST, PUT, PATCH, and DELETE methods,进行状态改变的，必须要有 CSRF token。

### Overriding Defaults to Set Custom Header

Several JavaScript libraries allow you to overriding default settings to have a header added automatically to all AJAX requests.

#### XMLHttpRequest (Native JavaScript)

```html
<script type="text/javascript">
  var csrf_token = document
    .querySelector("meta[name='csrf-token']")
    .getAttribute("content");
  function csrfSafeMethod(method) {
    // these HTTP methods do not require CSRF protection
    return /^(GET|HEAD|OPTIONS)$/.test(method);
  }
  var o = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function () {
    var res = o.apply(this, arguments);
    var err = new Error();
    if (!csrfSafeMethod(arguments[0])) {
      this.setRequestHeader("anti-csrf-token", csrf_token);
    }
    return res;
  };
</script>
```

#### axios

```html
<script type="text/javascript">
  var csrf_token = document
    .querySelector("meta[name='csrf-token']")
    .getAttribute("content");

  axios.defaults.headers.post["anti-csrf-token"] = csrf_token;
  axios.defaults.headers.put["anti-csrf-token"] = csrf_token;
  axios.defaults.headers.delete["anti-csrf-token"] = csrf_token;
  axios.defaults.headers.patch["anti-csrf-token"] = csrf_token;

  // Axios does not create an object for TRACE method by default, and has to be created manually.
  axios.defaults.headers.trace = {};
  axios.defaults.headers.trace["anti-csrf-token"] = csrf_token;
</script>
```

# CSRF 防御措施总结

## 基于 Token 的措施

### 最推荐的方案

服务器给每个用户会话生成 csrf token，有两种模式：

1. 同步 token 模式，将 csrf token 放在自定义 HTTP 请求头中
2. Signed Double-Submit Cookie 模式，放在 cookie 里，具体看文章介绍

## 不允许简单请求

### 适用于 AJAX/API 的模式

1. 设置“Access-Control-Allow-Origin”限定跨域的域名
2. 请求添加自定义请求头部，例如：`X-YOURSITE-CSRF-PROTECTION=1`，配置预检请求相关。

## 更深层的防御技术

### samesite

设置 Cookie 的 samesite（strict、lax、none）

### 使用标准头部验证源（Origin）

比较 target origin：X-Forwarded-Host 值，和 source origin:Origin 或者 Referer 的值

还可以用 cookies 的`__Host-`和`__Secure-`

### 用户交互

增加验证码

# 资料

[JSON Web Token 入门教程](https://ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

# 名词

## Social engineering

Social engineering is when people try to trick others into giving them sensitive information or doing things that might not be a good idea. Hackers and cybercriminals often use social engineering to get into systems or steal data.
