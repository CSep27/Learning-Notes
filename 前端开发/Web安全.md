# Web 安全

- 三要素：机密性，完整性，可用性

## 1. 身份认证和授权

1. 密码强度限制，动态验证码，输入次数限制
2. 公钥加密进行密码传输

## 2. 输入验证，防止跨站脚本攻击（XSS）

(如何防范 XSS)[https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html]

1. 不要相信用户输入的东西，要进行转义，框架基本都会完成
2. 设置 http-only，用户不能操作 cookie
3. 设置 secure，cookie 在 https 中才有效

## 3. 安全的传输，通过加密技术保护信息传输

1. HTTPS 安全传输 HTTP+SSL/TLS 证书

## 4. 防止跨站请求伪造（CSRF），只接受应用程序认可的请求

1. 使用 token，可用避开同源策略。不存储在 cookie 中，放在自定义 HTTP 请求头中。
2. JWT 默认不加密，可用使用秘钥加密，有效期设置较短，使用 HTTPS 传输
3. referer 检查（文章中说 not work）

英文资料：

[owasp 中对 CSRF 的介绍](https://owasp.org/www-community/attacks/csrf)

[如何防范 CSRF](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)

简单来说，以下用于防范 CSRF 的措施应该被遵守：

重要：XSS 会让所有的 CSRF 防御措施失效！

- 查看 the OWASP XSS Prevention Cheat Sheet，详细的指引关于如何防范 XSS 缺陷
- 第一点，检查你的框架有没有内置的 CSRF 防范措施，有的话使用它。
- 如果框架没有内置，添加 CSRF tokens 到所有状态改变的请求上（会导致网站操作的请求）并且在后端验证 tokens。
- 有状态的软件应该使用同步 token 模式（synchronizer token pattern）。
- 无状态的软件应该使用双重提交 cookies（double submit cookies）。
- 如果是一个 API 驱动的网站不应该使用`<form>`标签，考虑使用自定义请求头。
- 实现至少一种来自 Defense in Depth Mitigations 章节的防御措施。
- SameSite Cookie 属性可以用于 session cookies，但是小心**不要**特地为一个域名设置 cookie。这个举措会导致一个安全漏洞因为那个域名的所有子域名会分享这个 cookie，并且如果一个子域名有一个不在你控制范围的 CNAME 解析的话，尤其会成为一个问题。
- 对于高度敏感的操作，考虑实现基于保护措施的用户交互。
- 考虑使用标准头部验证域名。
- 对于改变状态的操作，不要使用 GET 请求。
- 如果你有任何理由这么做，保护这些资源免受 CSRF 攻击。

1. 使用 token，不存储在 cookie 中，放在自定义 HTTP 请求头中。token 应该满足

   - 每个用户会话都有不同的 token
   - 加密的
   - 不可预测的（large random value generated by a secure method）

2. 如果在服务端保持 token 状态有问题，可以使用替代方案：二次提交 cookie（Using A Double-Submit Cookie Pattern）

待完成...

# XSS

## 编码输出

### 对“HTML 属性上下文”做输出编码

使用引号包裹变量非常重要。

如果使用 JS 写 HTML 属性，使用 .setAttribute 和 [attribute]方法，因为他们会自动进行 HTML 属性编码

hardcoded 将信息固定地嵌入到软件程序中，以使用户无法轻易更改

对于 JSON，确保 Content-Type 是 application/json 而不是 text/html 来阻止 XSS

### CSS 上下文

变量只能被放在 CSS 属性值中，其他 CSS 上下文都是不安全的。

JS 操作 CSS：style.property = x，安全，自动编码

### URL 上下文

在 a 标签的 href 或 src 属性中添加 url，需要编码，遵循 HTML 属性编码规则

JS 操作：window.encodeURIComponent(x)

### 危险的上下文

```txt
<script>Directly in a script</script>
<!-- Inside an HTML comment -->
<style>Directly in CSS</style>
<div ToDefineAnAttribute=test />
<ToDefineATag href="/test" />
```

其他需要小心的区域包括：

- 回调函数
- 在 CSS 中处理 URL，比如`{ background-url : “javascript:alert(xss)”; }`
- 所有的 JS 时间处理(onclick(), onerror(), onmouseover())
- 不安全的 JS 方法：eval(), setInterval(), setTimeout()

不要把变量放到危险上下文中，即使已经进行了输出编码，输出编码无法完全防范 XSS

## HTML 净化

当用户需要写 HTML，开发者会让用户在一个所见即所得（WYSIWYG）的编辑器中修改内容的样式或者布局。这种情况下编码输出能阻止 XSS，但是也会破坏应用预期的效果。样式不会渲染，这种情况下，应该使用 HTML 净化。

HTML 净化会从变量中去掉危险的 HTML，返回一个安全的 HTML 字符串。推荐[DOMPurify](https://github.com/cure53/DOMPurify)

## 安全洼地 Safe Sinks

XSS 洼地就是变量在你页面中存在的地方。

XSS sinks are places where variables are placed into your webpage.

试着重构你的代码，移除像 innerHTML 这样指向不安全洼地的引用，改用 textContent 或者 value。

```js
elem.textContent = dangerVariable;
elem.insertAdjacentText(dangerVariable);
elem.className = dangerVariable;
elem.setAttribute(safeName, dangerVariable);
formfield.value = dangerVariable;
document.createTextNode(dangerVariable);
document.createElement(dangerVariable);
elem.innerHTML = DOMPurify.sanitize(dangerVar);
```

安全的 HTML 属性包括：align, alink, alt, bgcolor, border, cellpadding, cellspacing, class, color, cols, colspan, coords, dir, face, height, hspace, ismap, lang, marginheight, marginwidth, multiple, nohref, noresize, noshade, nowrap, ref, rel, rev, rows, rowspan, scrolling, shape, span, summary, tabindex, title, usemap, valign, value, vlink, vspace, width.

查看全面的列表，[DOMPurify allowlist](https://github.com/cure53/DOMPurify/blob/main/src/attrs.js)

## 其他手段

除了上述手段，考虑增加以下措施：

- cookie 属性 —— 改变 JS 和浏览器如何与 cookie 交互。可以限制 XSS 的影响，但是不能阻止有害内容的执行和处理漏洞的根本原因。
- 内容安全策略（CSP）——阻止内容被加载的列表。在实现中很容易出错，所以不应该成为主要的防御手段。是附加的防护。
- web 应用防火墙（WAF）—— 找到已知的攻击字符串然后阻止。WAF 是不可靠的并且新的绕开 WAF 的技术在频繁的出现。WAF 也不能处理漏洞的根本原因。另外，WAF 也不能解决在仅在客户端进行操作的这类 XSS 漏洞。WAF 不被推荐用于阻止 XSS，尤其是基于 DOM 的 XSS。

## XSS 防护手段总结
