# Web 安全

- 三要素：机密性，完整性，可用性

## 1. 身份认证和授权

1. 密码强度限制，动态验证码，输入次数限制
2. 公钥加密进行密码传输

## 2. 输入验证，防止跨站脚本攻击（XSS）

(如何防范 XSS)[https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html]

1. 不要相信用户输入的东西，要进行转义，框架基本都会完成
2. 设置 http-only，用户不能操作 cookie
3. 设置 secure，cookie 在 https 中才有效

## 3. 安全的传输，通过加密技术保护信息传输

1. HTTPS 安全传输 HTTP+SSL/TLS 证书

## 4. 防止跨站请求伪造（CSRF），只接受应用程序认可的请求

1. 使用 token，可用避开同源策略。不存储在 cookie 中，放在自定义 HTTP 请求头中。
2. JWT 默认不加密，可用使用秘钥加密，有效期设置较短，使用 HTTPS 传输
3. referer 检查（文章中说 not work）

英文资料：

[owasp 中对 CSRF 的介绍](https://owasp.org/www-community/attacks/csrf)

[如何防范 CSRF](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)

简单来说，以下用于防范 CSRF 的措施应该被遵守：

重要：XSS 会让所有的 CSRF 防御措施失效！

- 查看 the OWASP XSS Prevention Cheat Sheet，详细的指引关于如何防范 XSS 缺陷
- 第一点，检查你的框架有没有内置的 CSRF 防范措施，有的话使用它。
- 如果框架没有内置，添加 CSRF tokens 到所有状态改变的请求上（会导致网站操作的请求）并且在后端验证 tokens。
- 有状态的软件应该使用同步 token 模式（synchronizer token pattern）。
- 无状态的软件应该使用双重提交 cookies（double submit cookies）。
- 如果是一个 API 驱动的网站不应该使用`<form>`标签，考虑使用自定义请求头。
- 实现至少一种来自 Defense in Depth Mitigations 章节的防御措施。
- SameSite Cookie 属性可以用于 session cookies，但是小心**不要**特地为一个域名设置 cookie。这个举措会导致一个安全漏洞因为那个域名的所有子域名会分享这个 cookie，并且如果一个子域名有一个不在你控制范围的 CNAME 解析的话，尤其会成为一个问题。
- 对于高度敏感的操作，考虑实现基于保护措施的用户交互。
- 考虑使用标准头部验证域名。
- 对于改变状态的操作，不要使用 GET 请求。
- 如果你有任何理由这么做，保护这些资源免受 CSRF 攻击。

1. 使用 token，不存储在 cookie 中，放在自定义 HTTP 请求头中。token 应该满足

   - 每个用户会话都有不同的 token
   - 加密的
   - 不可预测的（large random value generated by a secure method）

2. 如果在服务端保持 token 状态有问题，可以使用替代方案：二次提交 cookie（Using A Double-Submit Cookie Pattern）

待完成...
