## 1. 算法概述

### 1.1 什么是算法

- 在计算机领域里，算法是一系列程序指令，用于处理特定的运算和逻辑问题。

### 1.2 什么是数据结构

- 数据结构是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。

1. 线性结构
   - 包括数组、链表，以及由它们衍生出来的栈、队列、哈希表
2. 树
   - 树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构。
3. 图
   - 图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系。

### 1.3 时间复杂度

- 执行算法的时间成本
- 由于受运行环境和输入规模的影响，代码的绝对执行时间是无法预估的。但我们可以预估代码的基本操作执行次数

#### 基本操作执行次数

- T(n) = 3n，执行次数是线性 的
- $T(n) = 5\log_2 n$，执行次数是用对数计算的
- T(n) = 2，执行次数是常量
- $T(n) = 0.5n^2 + 0.5n$，执行次数是用多项式计算的

#### 渐进时间复杂度

- 官方定义：若存在函数 f(n)，使得当 n 趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 T(n)=O(f(n))，称为 O(f(n))，O 为算法的渐进时间复杂度，简称为时间复杂度。因为渐进时间复杂度用大写 O 来表示，所以也被称为大 O 表示法 。
- 推导时间复杂度的几个原则
  1. 如果运行时间是常数量级，则用常数 1 表示
  2. 只保留时间函数中的最高阶项
  3. 如果最高阶项存在，则省去最高阶项前面的系数
- 例如 1. T(n) = 3n - 最高阶项为 3n，省去系数 3，则转化的时间复杂度为：T(n)=O(n) 直线 2. $T(n) = 5\log_2 n$ - 最高阶项为 5logn，省去系数 5，则转化的时间复杂度为：`$T(n) =O(\log_2 n)$` 右上曲线，n 越大，增长越来越缓慢 3. T(n) = 2 - 只有常数量级，则转化的时间复杂度为：T(n) =O(1) 纵坐标为 1 的水平直线 4. `$T(n) = 0.5n^2 + 0.5n$`， - 最高阶项为`$0.5n^2$` ，省去系数 0.5，则转化的时间复杂度为：
  `$T(n) =O(n^2)$` 右上曲线，n 越大，增长越快 - 当 n 足够大时，`$O(1)<O(\log_2 n)<O(n)<O(n^2 )$` n 足够大时，时间复杂度带来的差距就越明显

### 1.4 空间复杂度

- 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用了大 O 表示法。
- 程序占用空间大小的计算公式记作 S(n)=O(f(n)) ，其中 n 为问题的规模，f(n)为算法所占存储空间的函数

1. 常量空间
   - 当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作 O(1)
2. 线性空间
   - 当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模 n 成正比时，空间复杂度记作 O(n)
3. 二维空间
   - 当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模 n 成正比时，空间复杂度记作`$O(n^2 )$`
4. 递归空间
   - 递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。
   - “方法调用栈”包括进栈 和出栈 两个行为。
   - 当进入一个新方法时，执行入栈操作，把调用的方法和参数信息压入栈中。
   - 当方法返回时，执行出栈操作，把调用的方法和参数信息从栈中弹出。
   - 尾递归优化！！！
   - 执行递归操作所需要的内存空间和递归的深度成正比。纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是 n，那么空间复杂度就是 O(n) 。

### 1.5 时间与空间的取舍

- 在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间，也要提升程序的执行速度。

## 2. 数据结构基础

### 2.1 数组

#### 2.1.1 什么是数组

- 有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。
- 下标从 0 开始，一直到数组长度-1。在内存中顺序存储 ，因此可以很好地实现逻辑上的顺序表.
- 数组中的每一个元素，都存储在小小的内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。

#### 2.1.2 数组基本操作

1. 读取元素

- 给出一个数组下标，就可以读取到对应的数组元素。array[9]
- 输入的下标必须在数组的长度范围之内，否则会出现数组越界

2. 更新元素

- array[9] = 0
- 数组读取元素和更新元素的时间复杂度都是 O(1)

3. 插入元素

- 数组的实际元素数量有可能小于数组的长度
- 三种插入
  1. 尾部插入
     - 把插入的元素放在数组尾部的空闲位置，等同于更新元素
  2. 中间插入
     - 首先把插入位置及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上
  3. 超范围插入
     - 创建一个新数组，长度是旧数组的 2 倍，再把旧数组中的元素统统复制过去，实现数组扩容

4. 删除元素
   - 只涉及元素的移动，时间复杂度也是 O(n)

#### 2.1.3 数组的优势和劣势

- 优势：高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素
- 劣势：插入、删除元素都会导致大量元素被迫移动，影响效率
- 适合读操作多、写操作少的场景

## 2.2 链表

### 2.2.1 什么是链表

- 链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。
- 链表在内存中的存储方式则是随机存储

1. 单向链表

- 单向链表的每一个节点又包含两部分，一部分是存放数据的变量 data，另一部分是指向下一个节点的指针 next。
- 链表的第 1 个节点被称为头节点，最后 1 个节点被称为尾节点，尾节点的 next 指针指向空。

2. 双向链表

- 双向链表的每一个节点除了拥有 data 和 next 指针，还拥有指向前置节点的 prev 指针。

### 2.2.2 链表的基本操作

1. 查找节点

- 从头节点开始向后一个一个节点逐一查找。最坏的时间复杂度是 O(n)。

2. 更新节点

- 如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据替换成新数据即可。

3. 插入节点
   1. 尾部插入
      - 把最后一个节点的 next 指针指向新插入的节点即可。
   2. 头部插入
      - 第 1 步，把新节点的 next 指针指向原先的头节点。
      - 第 2 步，把新节点变为链表的头节点。
   3. 中间插入
      - 第 1 步，新节点的 next 指针，指向插入位置的节点。
      - 第 2 步，插入位置前置节点的 next 指针，指向新节点。
   - 只要内存空间允许，能够插入链表的元素是无穷无尽的。
4. 删除元素
   1. 尾部删除
      - 倒数第 2 个节点的 next 指针指向空
   2. 头部删除
      - 把链表的头节点设为原先头节点的 next 指针即可。解释：https://www.jianshu.com/p/db18e3aa5803
   3. 中间删除
      - 把要删除节点的前置节点的 next 指针，指向要删除元素的下一个节点即可
   - 许多高级语言，如 Java，拥有自动化的垃圾回收机制，所以我们不用刻意去释放被删除的节点，只要没有外部引用指向它们，被删除的节点会被自动回收。

- 如果不考虑插入、删除操作之前查找元素的过程，只考虑纯粹的插入和删除操作，时间复杂度都是 O(1)
- 所以如果需要在尾部频繁插入、删除元素，用链表更合适一些

### 2.3 栈和队列

#### 2.3.1 物理结构和逻辑结构

- 如果把物质层面的人体比作数据存储的物理结构，那么精神层面的人格则是数据存储的逻辑结构 。逻辑结构是抽象的概念，它依赖于物理结构而存在。

#### 2.3.2 什么是栈

- 栈（stack）是一种线性数据结构，它就像一个放入乒乓球的圆筒容器，栈中的元素只能先入后出 （First In Last Out，简称 FILO ）。最早进入的元素存放的位置叫作栈底 （bottom），最后进入的元素存放的位置叫作栈顶 （top）。

#### 2.3.3 栈的基本操作

1. 入栈 push
   - 把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。
2. 出栈 pop
   - 把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。

#### 2.3.4 什么是队列

- 队列（queue）是一种线性数据结构，队列中的元素只能先入先出 （First In First Out，简称 FIFO ）。队列的出口端叫作队头 （front），队列的入口端叫作队尾 （rear）。

#### 2.3.4 队列的基本操作

1. 入队
   - 入队（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。
2. 出队
   - 出队操作（dequeue）就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。

- 用数组实现的队列可以采用循环队列 的方式来维持队列容量的恒定。
  - 假设一个队列经过反复的入队和出队操作，还剩下 2 个元素，在“物理”上分布于数组的末尾位置。这时又有一个新元素将要入队。
  - 在数组不做扩容的前提下，可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。
  - 这样一来，整个队列的元素就“循环”起来了。在物理存储上，队尾的位置也可以在队头之前。当再有元素入队时，将其放入数组的首位，队尾指针继续后移即可。
  - 一直到（队尾下标+1）%数组长度 = 队头下标 时，代表此队列真的已经满了。需要注意的是，队尾指针指向的位置永远空出 1 位，所以**队列最大容量比数组长度小 1**。

#### 2.3.6 栈和队列的应用

1. 栈的应用

- 栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。
  - 例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。
  - 面包屑导航

2. 队列的应用

- 队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。
  - 例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。
  - 再如网络爬虫实现网站抓取时，也是把待抓取的网站 URL 存入队列中，再按照存入队列的顺序来依次抓取和解析的。

3. 双端队列

- 综合了栈和队列的优点，从队头一端可以入队或出队，从队尾一端也可以入队或出队。

4. 优先队列

- 谁的优先级最高，谁先出队。
- 不属于线性数据结构的范畴，它是基于二叉堆来实现的

### 2.4 神奇的散列表

#### 2.4.1 为什么需要散列表

- 散列表也叫作哈希表 （hash table），这种数据结构提供了键（Key） 和值（Value） 的映射关系。只要给出一个 Key，就可以高效查找到它所匹配的 Value，时间复杂度接近于 O(1) 。

#### 2.4.2 哈希函数

- 散列表在本质上也是一个数组。通过“中转站”，用某种方式，把散列表的 Key 和数组下标进行转换。这个中转站就叫作**哈希函数** 。
- 在 Java 及大多数面向对象的语言中，每一个对象都有属于自己的 hashcode，这个 hashcode 是区分不同对象的重要标识。无论对象自身的类型是什么，它们的 hashcode 都是一个整型变量。
- 转化成数组的下标的方式是按照数组长度进行取模运算。（实际上，JDK（Java 语言的软件开发工具包）中的哈希函数并没有直接采用取模运算，而是利用了位运算的方式来优化性能。不过在这里可以姑且简单理解成取模操作。）
- index = HashCode (Key) % Array.length
- 如给出一个长度为 8 的数组，则当 key=001121 时，index = HashCode ("001121") % Array.length = 1420036703 % 8 = 7

#### 2.4.3 散列表的读写操作

1. 写操作

- 在散列表中插入新的键值对（在 JDK 中叫作 Entry）
  1. 第 1 步，通过哈希函数，把 Key 转化成数组下标 5。
  2. 第 2 步，如果数组下标 5 对应的位置没有元素，就把这个 Entry 填充到数组下标 5 的位置。
- 当插入的 Entry 越来越多时，不同的 Key 通过哈希函数获得的下标有可能是相同的，这种情况，就叫作**哈希冲突** 。解决哈希冲突的方法主要有两种：
  1. 开放寻址法：当一个 Key 通过哈希函数获得对应的数组下标已被占用时，就寻找下一个空档位置。
  2. 链表法：HashMap 数组的每一个元素不仅是一个 Entry 对象，还是一个链表的头节点。每一个 Entry 对象通过 next 指针指向它的下一个 Entry 节点。当新来的 Entry 映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。

2. 读操作

- 第 1 步，通过哈希函数，把 Key 转化成数组下标 2。
- 第 2 步，找到数组下标 2 所对应的元素，如果这个元素的 Key 是 002936，那么就找到了；如果这个 Key 不是 002936，由于数组的每个元素都与一个链表对应，就顺着链表往下找，看看能否找到与 Key 相匹配的节点。

3. 扩容

- 当经过多次元素插入，散列表达到一定饱和度时，Key 映射位置发生冲突的概率会逐渐提高。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。这时就需要扩容。
  1. 扩容 ，创建一个新的 Entry 空数组，长度是原数组的 2 倍。
  2. 重新 Hash ，遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组中。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。

## 3.树

### 3.1 树和二叉树

#### 3.1.1 什么是树

- 在数据结构中，树的定义如下： 树（tree）是 n（n≥0）个节点的有限集。当 n=0 时，称为空树。在任意一个非空树中，有如下特点。
  1. 有且仅有一个特定的称为**根节点**（root）。
  2. 当 n>1 时，其余节点可分为 m（m>0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的**子树**。
  3. 树的末端，没有“孩子”，称作**叶子节点**（leaf）

![tree](./images/tree.png)

#### 3.1.2 什么是二叉树

这种树的**每个节点最多有 2 个孩子节点** ，也可能只有 1 个，或者没有孩子节点。

二叉树节点的两个孩子节点，一个被称为左孩子（left child） ，一个被称为右孩子（right child） 。

![二叉树](./images/二叉树.png)

二叉树的两种特殊形式：

1. 满二叉树

- 一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上
  ![满二叉树](./images/满二叉树.png)

2. 完全二叉树

- 对一个有 n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n。如果这个树所有节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为完全二叉树。
  ![完全二叉树](./images/完全二叉树.png)

二叉树属于逻辑结构，可以通过物理结构来表达二叉树

1. 链式存储结构
   - 二叉树的每一个节点包含 3 部分
     1. 存储数据的 data 变量
     2. 指向左孩子的 left 指针
     3. 指向右孩子的 right 指针
2. 数组
   - 使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。（个人理解：按照完全二叉树去编号每一个节点的位置，再依次放到数组中，如果该节点没有元素则该数组位置为空）
   - 假设一个父节点的下标是 parent，那么它的左孩子节点下标就是 2×parent + 1 ；右孩子节点下标就是 2×parent + 2 。

#### 3.1.3 二叉树的应用

最主要的应用在于进行查找操作和维持相对顺序。

1. 查找
   - 二叉查找树（binary search tree），在二叉树基础上再满足以下条件
     - 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
     - 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
     - 左、右子树也都是二叉查找树
   - 通过比较大小可以逐步查找到数据。对于一个**节点分布相对均衡** 的二叉查找树来说，如果节点总数是 n，那么搜索节点的时间复杂度就是 O(logn) ，和树的深度是一样的。
2. 维持相对顺序
   - 二叉查找树还有另一个名字——二叉排序树（binary sort tree。新插入的节点，同样要遵循二叉排序树的原则。但是有个致命的问题，例如在一个二叉查找树中依次插入 9、8、7、6、5、4，按照二叉查找树的插入规则，会出现一直在一个方向上延伸子节点的情况。这时就涉及到二叉树的**自平衡**了。
   - 二叉树自平衡的方式有红黑树、AVL 树、树堆等。

### 3.2 二叉树的遍历

#### 3.2.1 为什么要研究遍历

- 在计算机程序中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。
- 二叉树是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不同。
- 从节点之间位置关系的角度来看，二叉树的遍历分为 4 种。
  1. 前序遍历。
  2. 中序遍历。
  3. 后序遍历。
  4. 层序遍历。
- 从更宏观的角度来看，二叉树的遍历归结为两大类。
  1. 深度优先遍历 （前序遍历、中序遍历、后序遍历）。
  2. 广度优先遍历 （层序遍历）。

#### 3.3.2 深度优先遍历（Deep First Search）

- | 1(root) | -   | -   |
  | ------- | --- | --- |
- | 2（1 left） | 3（1 right） | -
  4（2 left） | 5（2 right） | - | 6(3 right)

1. 前序遍历
   - 输出顺序：根节点、左子树、右子树。
     1. 首先输出的是根节点 1。
     2. 由于根节点 1 存在左孩子，输出左孩子节点 2。
     3. 由于节点 2 也存在左孩子，输出左孩子节点 4。
     4. 节点 4 既没有左孩子，也没有右孩子，那么回到节点 2，输出节点 2 的右孩子节点 5。
     5. 节点 5 既没有左孩子，也没有右孩子，那么回到节点 1，输出节点 1 的右孩子节点 3。
   - 结果：1、2、4、5、3、6
2. 中序遍历
   - 输出顺序：左子树、根节点、右子树
     1. 首先访问根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深入访问下去，一直找到不再有左孩子的节点，并输出该节点。显然，第一个没有左孩子的节点是节点 4。
     2. 依照中序遍历的次序，接下来输出节点 4 的父节点 2。
     3. 再输出节点 2 的右孩子节点 5。
     4. 以节点 2 为根的左子树已经输出完毕，这时再输出整个二叉树的根节点 1。
     5. 由于节点 3 没有左孩子，所以直接输出根节点 1 的右孩子节点 3。
     6. 最后输出节点 3 的右孩子节点 6。
   - 结果：4、2、5、1、3、6
3. 后序遍历
   - 输出顺序：左子树、右子树、根节点
   - 结果：4、5、2、6、3、1

- 总结：按照输出顺序画三角形
- 二叉树用递归方式来实现前序、中序、后序遍历
- 绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解决，这种数据结构就是栈 。因为递归和栈都有回溯的特性。
- 递归实现示例代码：算法/code/二叉树

#### 3.2.3 广度优先遍历（Breath First Search）

- | 1(root) | -   | -   |
  | ------- | --- | --- |
- | 2（1 left） | 3（1 right） | -
  4（2 left） | 5（2 right） | - | 6(3 right)

- 层序遍历：二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。
- 输出：1、2、3、4、5、6
- 二叉树同一层次的节点之间是没有直接关联的，实现层序遍历需要借助一个队列来辅助工作。

### 3.3 什么是二插堆

#### 3.3.1 初识二插堆

- 二叉堆本质上是一种完全二叉树，二插堆的根节点叫堆顶，它分为两个类型：

1. 最大堆
   - 最大堆的任何一个父节点的值，都大于或等于 它左、右孩子节点的值。
2. 最小堆
   - 最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。

#### 3.3.2 二插堆的自我调整

1. 插入节点

- 当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。将新节点与其父节点比较，最小堆中如果比父节点的值要小，则新节点“上浮”，与父节点交换位置，以此类推。

2. 删除节点

- 删除的是堆顶的节点，将最后一个节点临时补到原本堆顶的位置，然后与左右孩子进行比较，根据情况进行“下沉”

3. 构建二插堆

- 把一个无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次“下沉” 。
- 堆的插入和删除操作，时间复杂度为 O(logn)。构建堆的时间复杂度是 O(n)。

#### 3.3.3 二插堆的代码实现

- 二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组中
- 假设父节点的下标是 parent，那么它的左孩子下标就是 2×parent+1 ；右孩子下标就是 2×parent+2 。

### 3.4 什么是优先队列

#### 3.4.1 优先队列的特点

- 优先队列不再遵循先入先出的原则，而是分为两种情况。
  - 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队
  - 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队

#### 3.4.2 优先队列的实现

- 用最大堆来实现最大优先队列，这样每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。同理用最小堆来实现最小优先队列。
- 二叉堆节点“上浮”和“下沉”的时间复杂度都是`$O(\log_2n)$` ，所以优先队列入队和出队的时间复杂度也是`$O(\log_2n)$`。
