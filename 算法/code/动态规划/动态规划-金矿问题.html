<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 
    “很久很久以前，有一位国王拥有5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人人数也不同。例如有的金矿储量是500kg黄金，需要5个工人来挖掘；有的金矿储量是200kg黄金，需要3个工人来挖掘……
    如果参与挖矿的工人的总数是10。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半的金矿。要求用程序求出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？”
    10名工人
    200kg黄金/3人
    300kg黄金/4人
    350kg黄金/3人
    400kg黄金/5人
    500kg黄金/5人

    如果最后一个金矿不挖，那么问题转化成10名工人挖前4个金矿的最优选择。
    如果最后一个金矿挖，那么需要5人，剩下就是5名工人挖前4个金矿的最优选择。

    这里在变化的就是金矿数和工人数。用F(5, 10)表示要计算出10个人挖5个金矿的最优选择。
    那么F(5, 10) = Max( F(4, 10), 500 + F(4, 5) )
    以此类推
    F(4, 10) = Max( F(3, 10), 400 + F(3, 5) )
    F(4, 5) = Max( F(3, 5), 400 + F(3, 0) )

    F(3, 5) = Max( F(2, 5), 350 + F(2, 2) ) 

    F(2, 2) 是 F(n-1, w - p[n - 1]) 
    此时n为3，n-1为2，w - p[n - 1] 为2 - 4，不成立 而需要F(2, 2)能够算下去的话，此时剩下是2个人，而挖第二个金矿，需要4个人，
    这种情况下 F(2, 2) 第一个2是剩下2个金矿，第二个2是，5-3=2个人，
    n-1 2 w - p[n-1] > 0

    对于挖 300kg金矿的情况需要4个人，但是这里只有2个人了，所以要先判断能不能挖，再往下走
    2 - 4 < 0 不成立，挖300kg金矿就不成立，只能走不挖300kg金矿的情况
    也就是 F(2, 2)  =  F(1, 2) 也就是说，人数不变，把金矿数 - 1继续往下执行看
    ...
    最后就是0个金矿，或者0个工人的最优选择，问题的边界

    把金矿数量设为n，工人数量设为w，
    金矿的含金量设为数组g[]，金矿所需开采人数设为数组p[]，
    设F(n, w)为n个金矿、w个工人时的最优收益函数，那么状态转移方程式如下。
    对于第i个金矿来说，
    第一种，第i个金矿不挖，金矿数坚毅，工人数不变，金矿收益转化为 F(n-1, w) (n >= 1, w < )
    第二种，第i个金矿挖，消耗p[i]个工人，金矿收益g[i]，金矿收益转化为g[i] + F(n-1, w - p[i])

    括号里的范围，就是
    n-1>=0 => n >=1
    w - p[n - 1] >= 0 => w >= p[n-1] 也就是说剩下的工人数要能够足以挖到下一个金矿

    比如说这里 F(4, 5) = Max( F(3, 5), 400 + F(3, 0) ) F(3, 0)工人数为0了，那么F(3,0)结果为0，

    F(n, w) = Max( F(n-1, w), g[n - 1] + F(n-1, w - p[n - 1]) ) (n >=1, w >= p[n-1])

    问题边界
    F(n, w) = 0 (n = 0 || w = 0)

   -->
    <script>
      const g = [400, 500, 200, 300, 350]; // 金矿价值
      const p = [5, 5, 3, 4, 3]; // 金矿需要的人数
      const fn1 = (n, w) => {
        // 问题边界
        if (n === 0 || w === 0) {
          return 0;
        }
        // 一种最优子结构
        // 所剩工人不足以挖当前金矿 不满足w >= p[n-1]
        // n<1的话 n就是等于0了，那么就是边界情况了。
        if (w < p[n - 1]) {
          // 把金矿数减1，工人数不变，往下执行看看人数能不能挖后面的金矿
          return fn1(n - 1, w);
        }
        // 常规情况下 两种最优子结构
        const a = fn1(n - 1, w);
        const b = g[n - 1] + fn1(n - 1, w - p[n - 1]);

        return Math.max(a, b);
      };
      console.log(fn1(5, 10));

      const fn2 = (n, w) => {
        // 问题边界
        if (n === 0 || w === 0) {
          return 0;
        }
        // 一种最优子结构
        // 所剩工人不足以挖当前金矿 不满足w >= p[n-1]
        // n<1的话 n就是等于0了，那么就是边界情况了。
        if (w < p[n - 1]) {
          // 把金矿数减1，工人数不变，往下执行看看人数能不能挖后面的金矿
          return fn2(n - 1, w);
        }
        // 常规情况下 两种最优子结构
        const a = fn2(n - 1, w);
        const b = g[n - 1] + fn2(n - 1, w - p[n - 1]);

        return Math.max(a, b);
      };
      console.log(fn2(5, 10));
    </script>
  </body>
</html>
