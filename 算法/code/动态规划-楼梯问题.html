<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 一个楼梯有 10 级台阶，你从下往上走，每跨一步只能向上迈 1 级或者 2 级台阶，请问一共有多少种走法？ -->
    <!-- 
      把问题拆分为子问题

      类比，1+..+99 的值 再加上100
      第一步，10级台阶问题，转化为先到第9级台阶，再迈一步到第10级台阶。
      那么这种情况下，走到第9步的走法，假设有5种，再跨一步就到第10级，那么此时到第10级就是5种走法。
      或者，先到第8级台阶，再迈两步到第10级。假设有4种，再跨两步就到第8级，那么此时到第10级就是4种走法。
      到第8级时，理论上可以选择再走1步或者2步，但是走1步到第9级的情况，已经放到上一个9+1的走法情况下了。
      这里是为了将问题划分为便于归纳的子问题，要将10拆分成9+1或者8+2。这样覆盖了所有到10级的情况。
      那么一共到第10级就是5+4种走法。
      ...
      那么走到第10步的走法，就等于走到第8步的走法加上走到第9步的走法。      
      F表示计算的函数，F(10) = F(9) + F(8)
      以此类推，F(9) = F(8) + F(7)，最后我们就需要知道F(3) = F(2) + F(1)
      那么最基础的值就是F(2)和F(1)，这两个很容易算出来
      F(1) = 1 一次迈一级台阶1种走法
      F(2) = 2 一次迈两级台阶；一级迈一级台阶，迈两次 共2两种走法

      所以类似于斐波那契数列

      归纳为三个要素：
      F(n-1) F(n-2) 是F(x)的最优子结构
      F(n) = F(n-1) + F(n-2) 状态转移方程
      F(1) = 1 F(2) = 2 问题的边界
     -->
    <script>
      let i1 = 0;
      const fn1 = (n) => {
        i1++;
        if (n === 1) {
          return 1;
        }
        if (n === 2) {
          return 2;
        }
        return fn1(n - 1) + fn1(n - 2);
      };
      console.log("fn1", fn1(20)); // 10946
      console.log("i1", i1); // 13529
      /*
      时间复杂度
      F(10) = F(9) + F(8) 计算2次
      F(9) = F(8) + F(7)
      ...
      F(4) = F(3) + F(2)
      F(3) = F(2) + F(1)
      F(2)
      F(1)
      那么 就需要10个2次 也就是2^n？

      第一次，计算F(10)
      执行算F(9)，就会进去F(9)到F(1)一直往下算到头F(2)和F(1)，最后得到F(9)的值，每一个值的获取都要计算两次
      执行算F(8)，就会进去F(8)到F(1)一直往下算到头，最后得到F(8)的值
      最后执行相加操作。
      这中间在计算F(9)与F(8)时就重复计算了很多量

      用树来表示，更清晰，更能看出来是2^n的关系，但是实际执行次数不是严格的2^n次方
             5
          4     3
        3  2   2  1
      2  1


      优化计算，在于很多值都重复计算了，可以保存下来，5在左边树深度往下的过程中，把432都算出来了，那么到右边的时候，直接取值就可以了。

      */
      //  存储值，空间换时间
      const map = {};
      let i2 = 0;
      const fn2 = (n) => {
        i2++;
        if (n === 1) {
          return 1;
        }
        if (n === 2) {
          return 2;
        }
        return map[n] ? map[n] : (map[n] = fn2(n - 1) + fn2(n - 2));
      };
      console.log("fn2", fn2(20)); // 10946
      console.log("i2", i2); // 37
      console.log("map", map);
      /*
      修改后 时间复杂度 O(n)
      空间复杂度 O(n)
      */

      // 更进一步，优化空间复杂度
      // 计算新阶段的值，把前面两个阶段的值都保存起来。
      // 用两个变量
      /*
             5
          4     3
        3  2   2  1
      2  1

      左边算出来4的值，在这个过程中算出来了 3和2，保存到临时变量a和b
      在右边计算3时，利用临时变量a和b

      */
      let i3 = 0;
      const fn3 = (n) => {
        if (n === 1) {
          return 1;
        }
        if (n === 2) {
          return 2;
        }
        let a = 1;
        let b = 2;
        let temp = 0;
        for (let i = 3; i <= n; i++) {
          i3++;
          temp = a + b;
          a = b;
          b = temp;
        }
        return temp;
      };
      console.log("fn3", fn3(20)); // 10946
      console.log("i3", i3); // 18
      // 最优解法，时间复杂度 O(n)，空间复杂度1
      /* 
      ！！！学习这个思想，三个变量，两个存储中间计算值，一个存储运算结果
      初始a,b,有值
      运算 a+b， temp存储计算结果

      然后往前递进，b值给a，temp给b，进行下一次计算
      给temp赋新值
      
      */
    </script>
  </body>
</html>
